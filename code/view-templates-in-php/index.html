<!DOCTYPE html>
<html lang="en">
  <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <link rel="shortcut icon" href="/images/samheuck-weblogo-small.png" type="image/png">
  <title>Sam Heuck | View templates in PHP</title>

  
  <meta name="description" content="A look at templating techniques in PHP and how they can improve separation of concerns and DRY to make for more orthogonal code." />
  

  <link rel="stylesheet" href="/pictonic/css/pictonic.css">
  <!--[if lt IE 8]><script src="/pictonic/js/pictonic.min.js"></script><![endif]-->

  <link href='https://fonts.googleapis.com/css?family=Ubuntu' rel='stylesheet' type='text/css'>

  <link href='/assets/global-da6362edcac15652ac50e4a679ff5518.css' rel='stylesheet' type='text/css' />


  </head>

  <body>
    <header>
     <a href="/" title="Home" rel="home">
  <img id="logo" src="/images/dizzy.png" alt="SamHeuck.com">
  <div id="site-name"><span>Sam</span> <span class='accent'>Heuck</span></div>
</a>

<nav>
  <ul>
    
      
      
      
    <li ><a  href="/about/">about</a></li>
    
      
      
      
    <li ><a  href="/resume/">resume</a></li>
    
      
      
      
    <li ><a  href="/blog/">blog</a></li>
    
  </ul>
</nav>

    </header>

    <div id="main">
      <section class="post">
        <h1 class='heading'>View templates in PHP</h1>
        <span class='post-date'>06 February 2013</span>
        <p><img src="/images/posts/view_templates_in_php01.png" alt="PHP" /></p>

<p>When first learning PHP, it is quite easy to shoot yourself in the foot. PHP is
forgiving and you can get away with writing some seriously crappy code.
Consequently, PHP programmers often follow a similar path as they develop their
skills. I started off writing horrendous code that was utterly unmaintainable. Of
course I ended up rewriting all of it. Twice. And through that process, one
which all programmers are familiar with, I learned some fundamentals of design
and architecture. “Separation of Concerns”, and “DRY” or “Don’t Repeat
Yourself” are terms you’ve no doubt heard, but they are a little abstract.
I hope to shed some light on these concepts.</p>

<p>A templating system is one way to significantly improve both separation of
concerns and DRY. View templates separate logic and data from design and layout,
and provide a set of common functions for creating views. This post will
introduce and explore templating techniques. The code in this post is mostly an
exercise, because normally, you will be using external libraries and frameworks
to do these same things. But writing your own system is a great way to level up
your skills, not to mention it will teach you to recognize these techniques in
existing systems, which will allow you to debug and troubleshoot more
effectively.</p>

<p>We’ll take a look at two common yet diametrical approaches to templating:
search &amp; replace templates, and include templates - as well as some other nifty
tricks.</p>

<p>Think about what goes into a simple page of HTML. First there is a standard
structure that never changes - Doctype followed by head with some meta tags, a
title, stylesheets and maybe some javascript. Then comes the body tag, and
some content. Some elements of this basic structure are the same on every
page, and other elements vary. This is the perfect situation to use a template.
The template will contain those elements that are static, and then PHP will
inject the dynamic elements into the template. This is DRY because we don’t
have to write the same bits of HTML for every single page in a site. It also
separates concerns by allowing content to be completely separate from layout.</p>

<p>Let’s start with the code that will actually create and display a page of HTML.</p>

<pre><code>&lt;?php
  $page = new HtmlPage();
  $page
    -&gt;setTitle('Home')
    -&gt;setMeta('keywords', 'some slightly-less-than-random words')
    -&gt;addStylesheet('base.css')
    -&gt;addStylesheet('my_beautiful_styles.css')
    -&gt;addScript('jquery.js')
    -&gt;addScript('awesome_blinky_text.js')
    -&gt;setBodyId('home')
    -&gt;setBodyClass('blue')
    -&gt;addContent($some_content)
    -&gt;addContent($more_content)
    -&gt;render('layout.phtml');
?&gt;
</code></pre>

<p>Did you notice this code is…</p>

<ul>
  <li>Object oriented</li>
  <li>Configurable (more on this later)</li>
  <li>Stringing function calls together <a href="http://en.wikipedia.org/wiki/Fluent_interface">(fluent interface)</a></li>
  <li>Declarative (stating what to do, not how)</li>
</ul>

<p>This PHP <em>writes</em> HTML code. Make note of the HTML elements that are being
injected: CSS, javascript, titles, ids and content. These are the dynamic
elements - different on each page. These dynamic elements could really come
from any source, a text file on the local file system, a database, or even
a RESTful API.</p>

<p>Once all of the dynamic elements are declared, the page is rendered. Let’s
take a closer look at the <code>HtmlPage::render()</code> function. It takes a single
argument that references a file containing the HTML template for a basic page.</p>

<pre><code>//layout.phtml
&lt;?php echo $this-&gt;doctype; ?&gt;;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
  &lt;head&gt;
    &lt;meta http-equiv="Content-Type" content="text/html;charset=utf-8" /&gt;
    &lt;?php echo $this-&gt;title; ?&gt;
    &lt;?php echo $this-&gt;meta; ?&gt;

    &lt;!-- STYLES --&gt;
    &lt;?php echo $this-&gt;stylesheets; ?&gt;

    &lt;!-- SCRIPTS --&gt;
    &lt;?php echo $this-&gt;scripts; ?&gt;
  &lt;/head&gt;

  &lt;?php echo $this-&gt;bodyTag; ?&gt;
  &lt;?php echo $this-&gt;content; ?&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>This HTML template uses PHP to print out the dynamic elements declared by the
HtmlPage class. <code>$this</code> refers to a specific instance of HtmlPage. So
the HtmlPage class is including the template file, and the template file refers
to instance variables of the HtmlPage class. Here’s how that works.</p>

<pre><code>&lt;?php
  ...

  /**
   * The render function.
   *
   * Responsible for displaying the page.
   *
   * @param String
   *   - path to template
   */
  public function render($template) {
    ob_start();
    $this-&gt;_include($template);
    return print ob_get_clean();
  }


  /**
   * Include wrapper.
   *
   * Using the include keyword, a
   * template is included.
   */
  private function _include() {
    include func_get_arg(0);
  }
?&gt;
</code></pre>

<p><code>HtmlPage::render()</code> creates an output buffer to capture the template content
being included. Then the include wrapper function is called with a reference to
a template file. This reference is just a string that represents the file path
to the template. The call to <code>func_get_arg(0)</code> limits the available scope of
the template to the object referenced by <code>$this</code>. This is the heart of the
include template technique.</p>

<p><strong>The major advantage</strong> to this technique is that there is now one place which
defines layout and static elements. The template can be changed or updated,
and all other instances of HtmlPage will in turn reflect that change.</p>

<p><em>So how do the methods generate HTML?</em></p>

<pre><code>public function __get($key) {
  // Tries to find and call a getter.
  $method = 'get' . ucfirst($key);
  return method_exists($this, $method) ? $this-&gt;$method() : null;
}
</code></pre>

<p>The function <code>__get()</code> is a <a href="http://php.net/manual/en/language.oop5.magic.php">magic function</a>
that gets called whenever a class variable that has not been defined is
referenced. In other words, I can refer to <code>$this-&gt;foo</code> in a template,
and that instance of HtmlPage will call the <code>__get(foo)</code> function because
the foo variable was not explicitly defined in the HtmlPage class.</p>

<p>The implementation of <code>__get()</code> can be customized, as is the case here, to
do anything we need. In this example, I use the passed in string to call another
function which returns HTML.</p>

<pre><code>// A 'getter' method, called by __get
public function getBodyTag()
{
  return sprintf("&lt;body%s%s&gt;", $this-&gt;_bodyId, $this-&gt;_bodyClass);
}
</code></pre>

<p>In the template, <code>&lt;?php echo $this-&gt;bodyTag; ?&gt;</code> is really calling the
getter function <code>HtmlPage::getBodyTag()</code> via the magical <code>__get()</code>
function. A similar getter function exists for each setter function.
<code>HtmlPage::addScript()</code> for instance, allows us to add as many scripts as we
like. Each string passed in from <code>HtmlPage::addScript()</code> gets stored in an
array, and the getter method iterates through the array, adds the appropriate
javascript element tags, and sets the source to the value of the string passed
in by addScript(). Each getter will have its own unique implementation depending
on the output that is needed. HtmlPage contains the setters and getters
necessary for creating HTML pages, but it could easily be extended to add new
functions.</p>

<p>Including pieces of content calls for a slightly different templating technique.
Individual pieces of content often contain a few dynamic elements - the name
of a logged in user for example. Search and replace templating is a technique
you can use to inject variables into a piece of content. The <code>addContent()</code>
function uses this technique. Its argument is actually an object defined by
this class.</p>

<pre><code>&lt;?php
class Partial
{
  private $_html;
  private $_items = array();

  public function __construct($file)
  {
    if (!$this-&gt;_html = file_get_contents($file, FILE_USE_INCLUDE_PATH)) {
      throw new Exception("Error Reading File: $file");
    }
  }

  public function set($item, $value)
  {
    $this-&gt;_items[$item] = $value;
    return $this;
  }

  public function output()
  {
    if (count($this-&gt;_items) &gt; 0 ) {
      foreach ($this-&gt;_items as $item =&gt; $value) {
          $replace = "[%$item]";
          $this-&gt;_html = str_replace($replace, $value, $this-&gt;_html);
      }
    }
    return preg_replace('/\[%.+\]/', '', $this-&gt;_html);
  }
}
?&gt;
</code></pre>

<p>A partial is a small piece of HTML that acts as mini-template. Dynamic
elements within the partial have a special syntax that distinguish them from
regular HTML. When <code>Partial::output()</code> is called, any named placeholders
(the dynamic elements) found in the partial are replaced with values stored and
indexed under their corresponding names. We use an associative array for this,
and to populate that array, we use the <code>Partial::set()</code> function to pass in
an index and a value. The <code>Partial::output()</code> function iterates through this
array, replacing any placeholder in the “mini-template” with the value of the
corresponding index in the associative array. Any placeholder that doesn’t have
a value set, gets replaced with an empty string by the reg-ex in the return
statement.</p>

<p>Long story short, little chunks of HTML can be appended to our HtmlPage’s
content variable. If we want to include some dynamic elements in that content,
we can use named placeholders. An example is in order.</p>

<pre><code>//index.php
...

$content = new Partial('some_really_cool_content.html');
$content-&gt;set('foo', 'bar');

$page-&gt;addContent($content);
</code></pre>

<p>And here is what “some_really_cool_content.html” might look like:</p>

<pre><code>&lt;h1&gt;This content is SWEEEEEEEEEET!&lt;/h1&gt;
&lt;span&gt;[%foo]&lt;/span&gt;
</code></pre>

<p><code>[%foo]</code> is the named placeholder and will be replaced by our amazing
content: “bar”. How very exciting. The data that replaces the placeholders could
come from a database somewhere, an RSS feed, really anything. Since we use PHP
to add the content and set the dynamic variables, we have the full flexibility
of PHP at our disposal. We could even use the output of other partials to
replace placeholders in a partial. Of course you don’t have to use any
placeholders at all; partials can be used to simply include snippets of pure
HTML.</p>

<p>When we use <code>&lt;?php echo $this-&gt;content ?&gt;</code>, <code>HtmlPage::getContent()</code>
will iterate through all partials which have been added, and call each of their
output functions in turn - printing out all of the dynamically generated code.
The content will appear in FIFO order (first in, first out) - in other
words, in the same order each partial was added.</p>

<p><strong>Caveats of search and replace</strong></p>

<ul>
  <li>Escaping unsafe strings is slightly trickier, especially with compound partials</li>
  <li>It’s expensive - lots of parsing overhead, reg-ex</li>
  <li>Performance concerns can be alleviated through cacheing, but this adds complexity</li>
  <li>Not as well suited for highly dynamic web applications with lots of users</li>
</ul>

<h2 id="nifty-tricks">Nifty tricks…</h2>

<p><em>How does <code>HtmlPage::addScript('script.js')</code> know where to find the script.js</em>
file?</p>

<p>HtmlPage is configurable.</p>

<pre><code>&lt;?php
...

public function __construct()
{
    $path = realpath(dirname(__FILE__)) . "/HtmlPage.ini";
    if (file_exists($path)) {
        $config = parse_ini_file($path);
        foreach($config as $key =&gt; $value) {
            $this-&gt;_config[$key] = $value;
        }
    }

    $this-&gt;_doctype = empty($this-&gt;_config['doctype.default'])
        ? 'XHTML_1_0_STRICT' : $this-&gt;_config['doctype.default'];
}
</code></pre>

<p>If HtmlPage finds a file called HtmlPage.ini in the same directory in which it
resides, it will parse that file and save any configuration settings in an
array. For instance, if a doctype has been specified in the config file, it will
use it, otherwise, it will use XHTML 1.0 STRICT.</p>

<p>The config file can be used to set base paths to scripts, stylesheets,
templates, etc.. It can also specify a default template, which allows you to
call <code>HtmlPage::render()</code> without any arguments at all. It will get the
template file from the config file. Of course, any argument passed in will
override the config file, so switching templates on the fly is still a cinch.
The config file is handy for setting a base title and separator for pages too.
If you end up extending HtmlPage, you can take advantage of the config file to
set sensible defaults for any new functionality. Here’s what my config file
looks like.</p>

<pre><code>//HtmlPage.ini
[base_paths]
javascript.basepath  = "/public/js/"
css.basepath         = "/public/css/"
templates.directory  = "templates/"

[defaults]
template.default = "layout.phtml"
doctype.default  = "XHTML_1_0_STRICT"
title.prefix     = "Test"
title.separator  = " | "
</code></pre>

<p><strong>The fluent interface…</strong> <br /> Fluent interfaces are very easy to implement in
PHP. All you have to do is <code>return $this;</code> in the function. Since <code>$this</code> is a
reference to an object, you can call another function, which also returns a
reference to an object, and so on.</p>

<p><strong>Prevent vital class variables from being overridden</strong> <br /> Magic functions in PHP
are quite useful. Since we have defined several class variables, such as
<code>$content</code>, that, if overwritten could potentially erase content from the HTML
page, we need a way to reserve these variables so that client code cannot
overwrite them. We want HtmlPage to be closed to modification, but open to
extension. <code>__set()</code> provides the functionality needed.</p>

<pre><code>//HtmlPage.php
&lt;?php
...

public final function __set($property, $value)
{
    if (method_exists($this, 'get' . ucfirst($property))
        || array_key_exists($property, get_class_vars(get_class($this)))
    ) {
        throw new Exception('Attempted to set a reserved variable');
    }
    $this-&gt;$property = $value;
    return $this;
}
</code></pre>

<p>Basically, any time a client assigns a class property, <code>__set()</code> checks to see if
there is a getter method, or a class variable already defined for that property.
If there is, <code>__set()</code> throws an exception. So the only way to add new class
properties to HtmlPage is to extend it.</p>

<h2 id="conclusion">Conclusion</h2>

<p>The code outlined here is simply to illustrate some basic techniques for templating.
This code <em>is</em> fully functional, and can be used to create web pages, but it’s
not really meant to be used as a foundational framework. I merely hope that it
helps you realize the power of separating those parts of an application
that are static into templates, and injecting the dynamic elements into those
templates. These techniques lead to more flexible, and maintainable code. Poke
around some of the major PHP frameworks like Zend, and you will see some of these
basic techniques in action.</p>

<p>Happy coding!</p>

      </section>
    </div>

    <aside>
      <img class="about-img" src="/images/sam.jpg" alt="Sam Heuck" title="Sam Heuck">

<div class='sb-block' id='recent-posts'>
  <h3>Recent Posts</h3>
  <ul>
  
    <li><span class='icon-kub-arw-right arrow'></span><a href="/coding/the-unforseen-downside-of-dabbling-in-a-new-language">The unforeseen challenge of dabbling in a new language</a></li>
  
    <li><span class='icon-kub-arw-right arrow'></span><a href="/code/why-clean-code-matters">Why clean code matters</a></li>
  
    <li><span class='icon-kub-arw-right arrow'></span><a href="/tools/meet-jekyll-the-static-site-generator-part-2">Meet Jekyll the Static Site Generator - Part 2</a></li>
  
    <li><span class='icon-kub-arw-right arrow'></span><a href="/tools/meet-jekyll-the-static-site-generator">Meet Jekyll, the Static Site Generator - Part 1</a></li>
  
    <li><span class='icon-kub-arw-right arrow'></span><a href="/code/view-templates-in-php">View templates in PHP</a></li>
  
    <li><span class='icon-kub-arw-right arrow'></span><a href="/books/books-part-1">Books part 1</a></li>
  
  </ul>
</div>

    </aside>
  </body>
  <script src='/assets/global-5732782c281fb04e82223e4fc519f9f4.js' type='text/javascript'></script>

<script type="text/javascript">var _gaq=_gaq||[];_gaq.push(['_setAccount','UA-30348707-2']);_gaq.push(['_trackPageview']);(function(){var a=document.createElement('script');a.type='text/javascript';a.async=true;a.src=('https:'==document.location.protocol?'https://ssl':'http://www')+'.google-analytics.com/ga.js';var s=document.getElementsByTagName('script')[0];s.parentNode.insertBefore(a,s)})();</script>

</html>
